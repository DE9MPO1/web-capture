# Interface (computing)

_Captured: 2015-10-24 at 19:36 from [en.m.wikipedia.org](https://en.m.wikipedia.org/wiki/Interface_(computing))_

Hardware interfaces exist in many of the components such as the various [buses](https://en.m.wikipedia.org/wiki/Bus_\(computing\)), [storage devices](https://en.m.wikipedia.org/wiki/Computer_data_storage), other [I/O](https://en.m.wikipedia.org/wiki/I/O) devices, etc. A hardware interface is described by the mechanical, electrical and logical signals at the interface and the protocol for sequencing them (sometimes called signaling).[[2]](https://en.m.wikipedia.org/wiki/Interface_\(computing\)) A standard interface, such as [SCSI](https://en.m.wikipedia.org/wiki/SCSI), decouples the design and introduction of computing hardware, such as [I/O](https://en.m.wikipedia.org/wiki/I/O) devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems.[[2]](https://en.m.wikipedia.org/wiki/Interface_\(computing\)) Hardware interfaces can be [parallel](https://en.m.wikipedia.org/wiki/Parallel_communication) with several electrical connections carrying parts of the data simultaneously, or [serial](https://en.m.wikipedia.org/wiki/Serial_communication) where data is sent one [bit](https://en.m.wikipedia.org/wiki/Bit) at a time .

A software interface may refer to a wide range of different types of interface at different "levels": an operating system may interface with pieces of hardware. [Applications](https://en.m.wikipedia.org/wiki/Application_software) or [programs](https://en.m.wikipedia.org/wiki/Computer_program) running on the operating system may need to interact via [streams](https://en.m.wikipedia.org/wiki/Stream_\(computing\)), and in [object oriented programs](https://en.m.wikipedia.org/wiki/Object-oriented_programming), objects within an application may need to interact via [methods](https://en.m.wikipedia.org/wiki/Method_\(computer_science\)).

A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e. interfaces.[[3]](https://en.m.wikipedia.org/wiki/Interface_\(computing\)) Software interfaces provide access to computer resources (such as memory, CPU, storage, etc.) of the underlying computer system; direct access (i.e. not through well designed interfaces) to such resources by software can have major ramifications--sometimes disastrous ones--for functionality and stability.

Interfaces between software components can provide: [constants](https://en.m.wikipedia.org/wiki/Constant_\(computer_science\)), [data types](https://en.m.wikipedia.org/wiki/Data_type), types of [procedures](https://en.m.wikipedia.org/wiki/Subroutine), [exception](https://en.m.wikipedia.org/wiki/Exception_handling) specifications and [method signatures](https://en.m.wikipedia.org/wiki/Method_signature). Sometimes, public [variables](https://en.m.wikipedia.org/wiki/Variable_\(programming\)) are also defined as part of an interface.

The interface of a software module _A_ is deliberately defined separately from the _[implementation](https://en.m.wikipedia.org/wiki/Implementation)_ of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other "private" variables, procedures, etc. Another software module _B_, for example the [client](https://en.m.wikipedia.org/wiki/Client_\(computing\)) to _A_, that interacts with _A_ is forced to do so _only_ through the published interface. One practical advantage of this arrangement is that replacing the implementation of _A_ by another implementation of the same interface should not cause _B_ to fail--how _A_ internally meets the requirements of the interface is not relevant to _B_, which [is only concerned](https://en.m.wikipedia.org/wiki/Separation_of_concerns) with the specifications of the interface. (See also [Liskov substitution principle](https://en.m.wikipedia.org/wiki/Liskov_substitution_principle).)

In [object-oriented](https://en.m.wikipedia.org/wiki/Object-oriented) languages, the term _interface_ is often used to define an [abstract type](https://en.m.wikipedia.org/wiki/Abstract_data_type) that contains no data or code, but defines behaviors as [method](https://en.m.wikipedia.org/wiki/Method_\(computer_science\)) signatures. A [class](https://en.m.wikipedia.org/wiki/Class_\(computer_science\)) having code and data for all the methods corresponding to that interface is said to _implement_ that interface.[[4]](https://en.m.wikipedia.org/wiki/Interface_\(computing\)) Furthermore, a class can implement multiple interfaces, and hence can _be_ of different types at the same time.[[5]](https://en.m.wikipedia.org/wiki/Interface_\(computing\))

An interface is hence a [type](https://en.m.wikipedia.org/wiki/Data_type) definition; anywhere an object can be exchanged (for example, in a [function](https://en.m.wikipedia.org/wiki/Function_\(computer_science\)) or [method](https://en.m.wikipedia.org/wiki/Method_\(computer_science\)) call) the _type_ of the object to be exchanged can be defined in terms of its interface rather than specifying a particular [class](https://en.m.wikipedia.org/wiki/Class_\(computer_science\)). This means that any class that implements that interface can be used. For example, a [dummy implementation](https://en.m.wikipedia.org/wiki/Skeleton_\(computer_programming\)) may be used to allow development to progress before the final implementation is available. In another case, a [fake or mock](https://en.m.wikipedia.org/wiki/Test-driven_development) implementation may be substituted during testing. Such [stub](https://en.m.wikipedia.org/wiki/Method_stub) implementations are replaced by real code later in the development process.

Usually a method defined in an interface contains no code and thus cannot itself be called; it must be implemented by non-abstract code to be run when it is invoked. An interface called "`[Stack](https://en.m.wikipedia.org/wiki/Stack_\(data_structure\))`" might define two methods: `push()` and `pop()`. It can be implemented in different ways, for example, `FastStack` and `GenericStack`--the first being fast, working with a stack of fixed size, and the second using a data structure that can be resized, but at the cost of somewhat lower speed.

Though interfaces can contain many methods they may contain only one or even none at all. For example, the [Java](https://en.m.wikipedia.org/wiki/Java_\(programming_language\)) language defines the interface `Readable` that has the single `read()` method; various implementations are used for different purposes, including `BufferedReader`, `FileReader`, `InputStreamReader`, `PipedReader`, and `StringReader`. [Marker interfaces](https://en.m.wikipedia.org/wiki/Marker_interface_pattern) like `Serializable` contain no methods at all and serve to provide run-time information to generic processing using [Reflection](https://en.m.wikipedia.org/wiki/Reflection_\(computer_programming\)).[[6]](https://en.m.wikipedia.org/wiki/Interface_\(computing\))

The use of interfaces allows a programming style called _programming to the interface_. The idea behind this is to base programming logic on the interfaces of the objects used, rather than on internal implementation details. Programming to the interface reduces dependency on implementation specifics and makes code more reusable.[[7]](https://en.m.wikipedia.org/wiki/Interface_\(computing\))

Pushing this idea to the extreme, [inversion of control](https://en.m.wikipedia.org/wiki/Inversion_of_control) leaves the _context_ to inject the code with the specific implementations of the interface that will be used to perform the work.

A **user interface** is a point of interaction between a computer and humans; it includes any number of [modalities](https://en.m.wikipedia.org/wiki/Modality_\(human%E2%80%93computer_interaction\)) of [interaction](https://en.m.wikipedia.org/wiki/Human-computer_interaction) (such as graphics, sound, position, movement...) where data is transferred between the user and the computer system.
